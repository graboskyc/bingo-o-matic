@page "/custom-bingo"
@using BingoApp.Models
@using BingoApp.Services
@using Microsoft.AspNetCore.Components
@using System.Web
@using Microsoft.AspNetCore.Components.Web
@implements IDisposable

@inject BingoSetService BingoService
@inject NavigationManager NavigationManager

<div class="bingo-container">
    <div class="bingo-header">
        <div class="bingo-title">
            <h1>Custom Bingo</h1>
            @if (selectedSet != null)
            {
                <p class="lead">Playing: @selectedSet.Name</p>
            }
            else
            {
                <p class="lead">Select a bingo set to play</p>
            }
        </div>
        <div class="bingo-controls">
            <div class="form-group me-2">
                <select class="form-select" id="bingoSet" @bind="pendingSetName" @bind:after="OnBingoSetSelectionChanged">
                    <option value="">Select a set...</option>
                    @foreach (var set in bingoSets)
                    {
                        <option value="@set.Name">@set.Name</option>
                    }
                </select>
            </div>
            <button class="btn btn-primary me-2" @onclick="SelectNext" disabled="@(selectedSet == null || isSelecting)">
                Draw Item
            </button>
            <button class="btn btn-outline-primary me-2" @onclick="ConfirmNewGame" disabled="@(selectedSet == null)">
                Reset
            </button>
        </div>
    </div>

    @if (selectedSet != null)
    {
        <div class="game-content">
            <div class="current-item @(isSelecting ? "selecting" : "") @(isAnimating ? "animate" : "")" aria-live="polite">
                <div class="item-display @(isSelected ? "selected" : "idle")" style="background-color: @currentThemeColor">
                    <span class="item">@(displayItem ?? "Ready to draw...")</span>
                </div>
            </div>

            <div class="called-items">
                <h4>Called Items</h4>
                <div class="called-items-grid">
                    @if (calledItems.Count > 0)
                    {
                        @foreach (var item in calledItems.AsEnumerable().Reverse())
                        {
                            bool isLatestItem = calledItems.IndexOf(item) == calledItems.Count - 1;
                            <div class="item-cell called @(isLatestItem ? "latest" : "previous")" style="@(isLatestItem ? $"background-color: {currentThemeColor}" : $"border-color: {currentThemeColor}")">
                                <span>@item</span>
                            </div>
                        }
                    }
                    else
                    {
                        <p>No items selected yet. Click "Draw Item" to begin.</p>
                    }
                </div>
            </div>
        </div>
    }
</div>

@* Confirmation Dialog *@
@if (showConfirmDialog)
{
    <div class="modal-backdrop show"></div>
    <div class="modal fade show" tabindex="-1" role="dialog" style="display: block;">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">@confirmTitle</h5>
                    <button type="button" class="btn-close" @onclick="CancelConfirmation"></button>
                </div>
                <div class="modal-body">
                    <p>@confirmMessage</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CancelConfirmation">Cancel</button>
                    <button type="button" class="btn btn-primary" @onclick="ConfirmAction">Confirm</button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    private string selectedSetName = "";
    private string pendingSetName = "";
    private List<BingoSet> bingoSets = new();
    private BingoSet? selectedSet;
    private bool isSelecting = false;
    private bool isSelected = false;
    
    // Bingo board state
    private List<string> availableItems = new List<string>();
    private List<string> calledItems = new List<string>();
    private Random random = new Random();
    private string? currentItem;
    private string? displayItem;
    private bool isAnimating = false;
    private CancellationTokenSource? animationCts;
    private string currentThemeColor = "";
    private readonly string[] darkColors = new[]
    {
        "#1E40AF", // Deep Blue
        "#065F46", // Forest Green
        "#831843", // Dark Pink
        "#3730A3", // Indigo
        "#7E22CE", // Purple
        "#9D174D", // Raspberry
        "#B45309", // Burnt Orange
        "#064E3B", // Dark Emerald
        "#134E4A", // Dark Teal
        "#450A0A", // Dark Red
        "#2563EB", // Medium Blue
        "#0891B2", // Cyan
        "#4338CA", // Medium Indigo
        "#7C3AED", // Medium Purple
        "#C026D3", // Medium Pink
        "#E11D48", // Medium Red
        "#EA580C", // Medium Orange
        "#65A30D", // Medium Green
        "#0D9488", // Medium Teal
        "#6D28D9", // Medium Violet
        "#BE185D", // Medium Magenta
        "#92400E", // Brown
        "#166534", // Medium Forest
        "#075985"  // Ocean Blue
    };

    // Confirmation dialog state
    private bool showConfirmDialog = false;
    private string confirmTitle = "";
    private string confirmMessage = "";
    private Func<Task>? confirmAction;

    protected override async Task OnInitializedAsync()
    {
        // Subscribe to changes
        BingoService.OnSetsChanged += OnBingoSetsChanged;
        
        // Load all bingo sets
        await LoadBingoSetsAsync();
        
        // Check if there's a set name in the query string
        var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        var query = HttpUtility.ParseQueryString(uri.Query);
        var setName = query["set"];
        if (!string.IsNullOrEmpty(setName))
        {
            selectedSetName = setName;
            pendingSetName = setName;
            await LoadSelectedSetAsync();
        }
    }
    
    private async Task LoadBingoSetsAsync()
    {
        bingoSets = (await BingoService.GetAllAsync()).ToList();
    }
    
    private void OnBingoSetsChanged()
    {
        InvokeAsync(async () => 
        {
            await LoadBingoSetsAsync();
            StateHasChanged();
        });
    }

    private void OnBingoSetSelectionChanged()
    {
        if (pendingSetName != selectedSetName && 
            selectedSet != null && 
            calledItems.Count > 0)
        {
            // Game in progress, confirm the change
            confirmTitle = "Change Bingo Set";
            confirmMessage = $"You're about to switch to a new bingo set. This will reset the current game. Are you sure?";
            showConfirmDialog = true;
            confirmAction = async () =>
            {
                selectedSetName = pendingSetName;
                await LoadSelectedSetAsync();
            };
        }
        else
        {
            // No game in progress or no change, just load
            selectedSetName = pendingSetName;
            _ = LoadSelectedSetAsync();
        }
    }

    private async Task LoadSelectedSetAsync()
    {
        if (!string.IsNullOrEmpty(selectedSetName))
        {
            selectedSet = await BingoService.GetByNameAsync(selectedSetName);
            if (selectedSet != null)
            {
                ResetGame();
            }
        }
        else
        {
            selectedSet = null;
        }
    }
    
    // Keep the synchronous version for backward compatibility
    private void LoadSelectedSet()
    {
        if (!string.IsNullOrEmpty(selectedSetName))
        {
            selectedSet = BingoService.GetByName(selectedSetName);
            if (selectedSet != null)
            {
                ResetGame();
            }
        }
        else
        {
            selectedSet = null;
        }
    }

    private void ResetGame()
    {
        // Cancel any ongoing animations first
        animationCts?.Cancel();
        if (animationCts != null)
        {
            animationCts.Dispose();
            animationCts = null;
        }

        if (selectedSet?.Items?.Length > 0)
        {
            availableItems = new List<string>(selectedSet.Items);
            calledItems.Clear();
            currentItem = null;
            displayItem = null;
            isSelecting = false;
            isSelected = false;
            isAnimating = false;
            // Assign a new random color theme
            string previousColor = currentThemeColor;
            string newColor;
            do
            {
                newColor = darkColors[random.Next(darkColors.Length)];
            } while (darkColors.Length > 1 && newColor == previousColor);
            currentThemeColor = newColor;
            StateHasChanged();
        }
    }

    private void ConfirmNewGame()
    {
        if (calledItems.Count > 0)
        {
            confirmTitle = "Confirm New Game";
            confirmMessage = "Are you sure you want to start a new game? This will reset the current game.";
            showConfirmDialog = true;
            confirmAction = () =>
            {
                NewGame();
                return Task.CompletedTask;
            };
        }
        else
        {
            // No game in progress, just reset
            NewGame();
        }
    }

    private void NewGame()
    {
        ResetGame();
    }

    private void CancelConfirmation()
    {
        showConfirmDialog = false;
        pendingSetName = selectedSetName; // Reset pending selection if canceled
        StateHasChanged();
    }

    private async Task ConfirmAction()
    {
        showConfirmDialog = false;
        if (confirmAction != null)
        {
            await confirmAction.Invoke();
            confirmAction = null;
        }
    }

    private async Task SelectNext()
    {
        if (availableItems.Count == 0 || isSelecting)
        {
            return;
        }

        try
        {
            isSelecting = true;
            isSelected = false;
            // Start with a random item visible right away
            displayItem = availableItems[random.Next(availableItems.Count)];
            currentItem = null;
            isAnimating = true;
            StateHasChanged();

            // Cancel any existing animation
            animationCts?.Cancel();
            animationCts = new CancellationTokenSource();
            var token = animationCts.Token;

            // Fast cycling at the beginning
            var fastRotations = 15;
            for (int i = 0; i < fastRotations && !token.IsCancellationRequested; i++)
            {
                displayItem = availableItems[random.Next(availableItems.Count)];
                StateHasChanged();
                await Task.Delay(40, token); // Fast speed - items changing quickly
            }
            
            // Medium speed cycling
            var mediumRotations = 10;
            for (int i = 0; i < mediumRotations && !token.IsCancellationRequested; i++)
            {
                displayItem = availableItems[random.Next(availableItems.Count)];
                StateHasChanged();
                await Task.Delay(80 + (i * 5), token); // Medium speed - slowing down
            }
            
            // Slow down dramatically for final selections
            var slowRotations = 7;
            for (int i = 0; i < slowRotations && !token.IsCancellationRequested; i++)
            {
                displayItem = availableItems[random.Next(availableItems.Count)];
                StateHasChanged();
                await Task.Delay(150 + (i * 50), token); // Progressively slower
            }

            if (token.IsCancellationRequested)
                return;

            // Select the final item
            int randomIndex = random.Next(0, availableItems.Count);
            currentItem = availableItems[randomIndex];
            displayItem = currentItem;
            availableItems.RemoveAt(randomIndex);
            calledItems.Add(currentItem);

            // Show final selection without animation
            isSelecting = false;
            isSelected = true;
            // Don't use the spinning animation
            isAnimating = false;
            StateHasChanged();
        }
        catch (OperationCanceledException)
        {
            // Animation was cancelled
        }
        finally
        {
            isSelecting = false;
            if (animationCts != null)
            {
                animationCts.Dispose();
                animationCts = null;
            }
        }
    }

    private void ToggleItem(string item)
    {
        if (calledItems.Contains(item))
        {
            calledItems.Remove(item);
            availableItems.Add(item);
        }
        else
        {
            calledItems.Add(item);
            availableItems.Remove(item);
        }
        StateHasChanged();
    }

    public void Dispose()
    {
        // Clean up any resources when the component is disposed
        BingoService.OnSetsChanged -= OnBingoSetsChanged;
        animationCts?.Cancel();
        animationCts?.Dispose();
        animationCts = null;
    }
}
