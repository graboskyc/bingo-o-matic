@page "/custom-bingo"
@using Microsoft.AspNetCore.Components
@using System.Web
@using Microsoft.AspNetCore.Components.Web
@using BingoApp.Models
@using BingoApp.Services
@implements IDisposable

@inject BingoSetService BingoService
@inject NavigationManager NavigationManager
@inject ILocalBrowserStorageService LocalStorageService

<div class="bingo-container">
    <div class="bingo-header">
        <div class="bingo-controls">
            <div class="selector-row">
                <div class="form-group">
                    <select class="form-select" id="bingoSet" @bind="pendingSetName" @bind:after="OnBingoSetSelectionChanged">
                        <option value="">Select a set...</option>
                        @foreach (var set in bingoSets)
                        {
                            <option value="@set.Name">@set.Name</option>
                        }
                    </select>
                </div>
                <a href="/custom-bingo/manage" class="btn btn-outline-secondary manage-btn" title="Manage Bingo Sets" aria-label="Manage Bingo Sets">
                    <i class="bi bi-gear"></i>
                </a>
            </div>
            <button class="btn btn-primary me-2" @onclick="SelectNext" disabled="@(selectedSet == null || isSelecting)">
                Draw Item
            </button>
            <button class="btn btn-outline-primary me-2" @onclick="ConfirmNewGame" disabled="@(selectedSet == null || isSelecting)">
                Reset
            </button>
            <div class="mode-toggle @(isSelecting ? "disabled" : "")" role="group" aria-label="Selection mode">
                <button type="button" 
                        class="mode-toggle-btn @(!useWheel ? "active" : "")" 
                        @onclick="() => SetMode(false)"
                        disabled="@isSelecting"
                        aria-pressed="@(!useWheel)">
                    <i class="bi bi-list-ul"></i>
                    <span>Cards</span>
                </button>
                <button type="button" 
                        class="mode-toggle-btn @(useWheel ? "active" : "")" 
                        @onclick="() => SetMode(true)"
                        disabled="@isSelecting"
                        aria-pressed="@useWheel">
                    <i class="bi bi-palette"></i>
                    <span>Wheel</span>
                </button>
            </div>
        </div>
    </div>

    @if (selectedSet != null)
    {
        <div class="game-content">
            @if (isSelecting && useWheel)
            {
                <div class="wheel-overlay @(isWheelDramatic ? "dramatic" : "")">
                    <div class="wheel-container @(isWheelSlowingDown ? "slowing-down" : "") @(isWheelDramatic ? "dramatic-finale" : "")">
                    <div class="wheel @(isWheelDramatic ? "dramatic-glow" : "")" style="transform: rotate(@(wheelRotation)deg)">
                        @foreach (var (item, index) in availableItems.Select((value, i) => (value, i)))
                        {
                            var segmentAngle = 360.0 / availableItems.Count;
                            var startAngle = segmentAngle * index;
                            var endAngle = segmentAngle * (index + 1);
                            
                            // Add small overlap to eliminate gaps between segments
                            // Use larger overlap for fewer segments to prevent gaps
                            var overlapAngle = availableItems.Count <= 5 ? 2.0 : 0.5; // Larger overlap for fewer segments
                            var adjustedStartAngle = startAngle - overlapAngle;
                            var adjustedEndAngle = endAngle + overlapAngle;
                            
                            var textAngle = startAngle + (segmentAngle / 2); // Center text in segment
                            var (translateX, translateY) = GetDynamicTextPosition();
                            var clipPath = $"polygon(50% 50%, {50 + 50 * Math.Cos((adjustedStartAngle - 90) * Math.PI / 180)}% {50 + 50 * Math.Sin((adjustedStartAngle - 90) * Math.PI / 180)}%, {50 + 50 * Math.Cos((adjustedEndAngle - 90) * Math.PI / 180)}% {50 + 50 * Math.Sin((adjustedEndAngle - 90) * Math.PI / 180)}%)";
                            <div class="wheel-segment" style="background-color: @(GetWheelSegmentColor(index)); clip-path: @clipPath">
                            </div>
                            <span class="wheel-text" style="transform: rotate(@(textAngle)deg) translateX(@(translateX)px) translateY(@(translateY)%); font-size: @GetDynamicFontSize();">@item</span>

                        }
                    </div>
                        <div class="wheel-pointer @(isWheelDramatic ? "dramatic-pointer" : "")"></div>
                        
                        @* Dramatic effects *@
                        @if (showWheelSparkles)
                        {
                            <div class="wheel-sparkles">
                                @for (int i = 0; i < 12; i++)
                                {
                                    <div class="sparkle" style="--delay: @(i * 0.1)s; --angle: @(i * 30)deg;"></div>
                                }
                            </div>
                        }
                        
                        @if (isWheelDramatic)
                        {
                            <div class="dramatic-flash"></div>
                            <div class="victory-burst"></div>
                        }
                    </div>
                </div>
            }
            else
            {
                <div class="current-item @(isSelecting ? "selecting" : "") @(isAnimating ? "animate" : "")" aria-live="polite">
                    <div class="item-display @(isSelected ? "selected" : "idle")" style="background-color: @currentThemeColor">
                        <span class="item">@(displayItem ?? "Ready to draw...")</span>
                    </div>
                </div>

                <div class="called-items">
                    <h4>Called Items</h4>
                    <div class="called-items-grid">
                        @if (calledItems.Count > 0)
                        {
                            @foreach (var item in calledItems.AsEnumerable().Reverse())
                            {
                                bool isLatestItem = calledItems.IndexOf(item) == calledItems.Count - 1;
                                <div class="item-cell called @(isLatestItem ? "latest" : "previous")" style="@(isLatestItem ? $"background-color: {currentThemeColor}" : $"border-color: {currentThemeColor}")">
                                    <span>@item</span>
                            </div>
                            }
                        }
                        else
                        {
                            <p>No items selected yet. Click "Draw Item" to begin.</p>
                        }
                    </div>
                </div>
            }
        </div>
    }
</div>

@* Confirmation Dialog *@
@if (showConfirmDialog)
{
    <div class="modal-backdrop show"></div>
    <div class="modal fade show" tabindex="-1" role="dialog" style="display: block;">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">@confirmTitle</h5>
                    <button type="button" class="btn-close" @onclick="CancelConfirmation"></button>
                </div>
                <div class="modal-body">
                    <p>@confirmMessage</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CancelConfirmation">Cancel</button>
                    <button type="button" class="btn btn-primary" @onclick="ConfirmAction">Confirm</button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    private string selectedSetName = "";
    private string pendingSetName = "";
    private List<BingoSet> bingoSets = new();
    private BingoSet? selectedSet;
    private bool isSelecting = false;
    private bool isSelected = false;
    
    // Bingo board state
    private List<string> availableItems = new List<string>();
    private List<string> calledItems = new List<string>();
    private Random random = new Random();
    private string? currentItem;
    private string? displayItem;
    private bool isAnimating = false;
    private CancellationTokenSource? animationCts;
    private string currentThemeColor = "";
    private readonly string[] darkColors = new[]
    {
        "#1E40AF", // Deep Blue
        "#065F46", // Forest Green
        "#831843", // Dark Pink
        "#3730A3", // Indigo
        "#7E22CE", // Purple
        "#9D174D", // Raspberry
        "#B45309", // Burnt Orange
        "#064E3B", // Dark Emerald
        "#134E4A", // Dark Teal
        "#450A0A", // Dark Red
        "#2563EB", // Medium Blue
        "#0891B2", // Cyan
        "#4338CA", // Medium Indigo
        "#7C3AED", // Medium Purple
        "#C026D3", // Medium Pink
        "#E11D48", // Medium Red
        "#EA580C", // Medium Orange
        "#65A30D", // Medium Green
        "#0D9488", // Medium Teal
        "#6D28D9", // Medium Violet
        "#BE185D", // Medium Magenta
        "#92400E", // Brown
        "#166534", // Medium Forest
        "#075985"  // Ocean Blue
    };

    private readonly string[] wheelColors = new[]
    {
        "#E74C3C", // Red
        "#3498DB", // Blue  
        "#2ECC71", // Green
        "#F39C12", // Orange
        "#9B59B6", // Purple
        "#1ABC9C", // Teal
        "#E67E22", // Carrot Orange
        "#8E44AD", // Wisteria Purple
        "#16A085", // Dark Turquoise
        "#C0392B"  // Dark Red
    };
    
    private string GetWheelSegmentColor(int index)
    {
        // For better visual separation, ensure adjacent segments have different colors
        // Also ensure first and last segments never match when there are enough segments
        var totalSegments = availableItems.Count;
        
        // If we have fewer segments than colors, space them out
        if (totalSegments <= wheelColors.Length)
        {
            // Calculate spacing to distribute colors evenly
            var spacing = Math.Max(1, wheelColors.Length / totalSegments);
            var colorIndex = (index * spacing) % wheelColors.Length;
            
            // Special handling to ensure first and last segments don't match when possible
            if (totalSegments > 2 && index == totalSegments - 1) // Last segment
            {
                var firstSegmentColorIndex = 0; // First segment always uses index 0 with spacing
                if (colorIndex == firstSegmentColorIndex)
                {
                    // Move to next available color that's different from first segment
                    colorIndex = (colorIndex + spacing) % wheelColors.Length;
                }
            }
            
            return wheelColors[colorIndex];
        }
        else
        {
            // More segments than colors - use alternating pattern to avoid adjacency
            // This creates a pattern like: 0,2,4,1,3,5,0,2,4... which maximizes separation
            var colorIndex = (index * 2) % wheelColors.Length;
            if (index >= wheelColors.Length / 2)
            {
                colorIndex = ((index - wheelColors.Length / 2) * 2 + 1) % wheelColors.Length;
            }
            
            // Additional protection for first/last segment matching
            if (index == totalSegments - 1) // Last segment
            {
                var firstSegmentColorIndex = 0; // First segment uses index 0
                if (colorIndex == firstSegmentColorIndex)
                {
                    // Find an alternative color that's different from first segment and previous segment
                    var previousSegmentIndex = totalSegments - 2;
                    var previousColorIndex = (previousSegmentIndex * 2) % wheelColors.Length;
                    if (previousSegmentIndex >= wheelColors.Length / 2)
                    {
                        previousColorIndex = ((previousSegmentIndex - wheelColors.Length / 2) * 2 + 1) % wheelColors.Length;
                    }
                    
                    // Try to find a color that's different from both first and previous segments
                    for (int offset = 1; offset < wheelColors.Length; offset++)
                    {
                        var alternativeIndex = (colorIndex + offset) % wheelColors.Length;
                        if (alternativeIndex != firstSegmentColorIndex && alternativeIndex != previousColorIndex)
                        {
                            colorIndex = alternativeIndex;
                            break;
                        }
                    }
                }
            }
            
            return wheelColors[colorIndex];
        }
    }

    private string GetDynamicFontSize()
    {
        // Calculate font size based on number of items and length of longest item
        var itemCount = availableItems.Count;
        var maxLength = availableItems.Count > 0 ? availableItems.Max(s => s.Length) : 0;
        
        // If more than 50 items, keep original smaller sizes
        if (itemCount > 50)
        {
            if (maxLength > 15)
            {
                if (itemCount <= 3) return "1.0rem";
                if (itemCount <= 8) return "0.9rem";
                if (itemCount <= 15) return "0.8rem";
                return "0.7rem";
            }
            else if (maxLength > 10)
            {
                if (itemCount <= 3) return "1.2rem";
                if (itemCount <= 8) return "1.0rem";
                if (itemCount <= 15) return "0.9rem";
                if (itemCount <= 25) return "0.8rem";
                return "0.7rem";
            }
            else
            {
                if (itemCount <= 3) return "1.4rem";
                if (itemCount <= 8) return "1.2rem";
                if (itemCount <= 15) return "1.0rem";
                if (itemCount <= 25) return "0.9rem";
                if (itemCount <= 35) return "0.8rem";
                return "0.7rem";
            }
        }
        
        // Increased sizes by 1.5x for <= 50 items
        if (maxLength > 15)
        {
            // Very conservative sizes for very long text
            if (itemCount <= 3) return "1.5rem";
            if (itemCount <= 8) return "1.35rem";
            if (itemCount <= 15) return "1.2rem";
            return "1.05rem";
        }
        else if (maxLength > 10)
        {
            // Conservative sizes for long text
            if (itemCount <= 3) return "1.8rem";
            if (itemCount <= 8) return "1.5rem";
            if (itemCount <= 15) return "1.35rem";
            if (itemCount <= 25) return "1.2rem";
            return "1.05rem";
        }
        else
        {
            // Normal sizing for shorter text
            if (itemCount <= 3) return "2.1rem";
            if (itemCount <= 8) return "1.8rem";
            if (itemCount <= 15) return "1.5rem";
            if (itemCount <= 25) return "1.35rem";
            if (itemCount <= 35) return "1.2rem";
            return "1.05rem";
        }
    }

    private (double translateX, double translateY) GetDynamicTextPosition()
    {
        // Position text with more conservative inward placement
        var itemCount = availableItems.Count;
        
        // Calculate position with more conservative inward placement
        // The wheel radius is approximately 250px (half of min 500px wheel size)
        var baseRadius = 200; // Further reduced to keep text well inside wheel
        
        // Adjust text distance from center based on number of items and text length
        var maxLength = availableItems.Count > 0 ? availableItems.Max(s => s.Length) : 0;
        double textDistanceRatio;
        
        // More conservative placement for longer text
        if (maxLength > 15)
        {
            textDistanceRatio = 0.60; // Very conservative for very long text
        }
        else if (maxLength > 10)
        {
            textDistanceRatio = 0.65; // Conservative for long text
        }
        else
        {
            // For normal length text, still be more conservative than before
            if (itemCount <= 3)
            {
                textDistanceRatio = 0.70; // Much more inward for large segments
            }
            else if (itemCount <= 8)
            {
                textDistanceRatio = 0.75; // More inward for medium segments
            }
            else if (itemCount <= 15)
            {
                textDistanceRatio = 0.80; // Slightly more inward for smaller segments
            }
            else
            {
                textDistanceRatio = 0.85; // Still keep some safe distance from edge
            }
        }
        
        var translateX = baseRadius * textDistanceRatio;
        
        // Y translation - keep text centered with more offset for longer text
        double translateY;
        if (maxLength > 15)
        {
            translateY = -20; // Larger offset for very long text
        }
        else if (maxLength > 10)
        {
            translateY = -18; // Large offset for long text
        }
        else if (itemCount <= 5)
        {
            translateY = -15; // Normal offset for few items
        }
        else if (itemCount <= 15)
        {
            translateY = -12; // Slightly smaller offset
        }
        else
        {
            translateY = -10; // Minimal offset for many items
        }
        
        return (translateX, translateY);
    }

    // Confirmation dialog state
    private bool showConfirmDialog = false;
    private string confirmTitle = "";
    private string confirmMessage = "";
    private Func<Task>? confirmAction;

    // Wheel state
    private bool useWheel = false;
    private double wheelRotation = 0;
    private bool isWheelSlowingDown = false;
    private bool isWheelDramatic = false;
    private bool showWheelSparkles = false;
    private const string WheelPreferenceKey = "bingo_wheel_preference";

    protected override async Task OnInitializedAsync()
    {
        // Subscribe to changes
        BingoService.OnSetsChanged += OnBingoSetsChanged;
        
        // Load wheel preference
        await LoadWheelPreferenceAsync();
        
        // Load all bingo sets
        await LoadBingoSetsAsync();
        
        // Check if there's a set name in the query string
        var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        var query = HttpUtility.ParseQueryString(uri.Query);
        var setName = query["set"];
        if (!string.IsNullOrEmpty(setName))
        {
            selectedSetName = setName;
            pendingSetName = setName;
            await LoadSelectedSetAsync();
        }
    }
    
    private async Task LoadBingoSetsAsync()
    {
        bingoSets = (await BingoService.GetAllAsync()).ToList();
    }
    
    private async Task LoadWheelPreferenceAsync()
    {
        try
        {
            var savedPreference = await LocalStorageService.GetItemAsync<bool?>(WheelPreferenceKey);
            useWheel = savedPreference ?? false;
        }
        catch
        {
            // If loading fails, default to false
            useWheel = false;
        }
    }
    
    private async Task SaveWheelPreferenceAsync()
    {
        try
        {
            await LocalStorageService.SetItemAsync(WheelPreferenceKey, useWheel);
        }
        catch
        {
            // Silently fail if saving doesn't work
        }
    }
    
    private void OnBingoSetsChanged()
    {
        InvokeAsync(async () => 
        {
            await LoadBingoSetsAsync();
            StateHasChanged();
        });
    }

    private async Task OnWheelPreferenceChanged()
    {
        await SaveWheelPreferenceAsync();
    }

    private void OnBingoSetSelectionChanged()
    {
        if (pendingSetName != selectedSetName && 
            selectedSet != null && 
            calledItems.Count > 0)
        {
            // Game in progress, confirm the change
            confirmTitle = "Change Bingo Set";
            confirmMessage = $"You're about to switch to a new bingo set. This will reset the current game. Are you sure?";
            showConfirmDialog = true;
            confirmAction = async () =>
            {
                selectedSetName = pendingSetName;
                await LoadSelectedSetAsync();
            };
        }
        else
        {
            // No game in progress or no change, just load
            selectedSetName = pendingSetName;
            _ = LoadSelectedSetAsync();
        }
    }

    private async Task LoadSelectedSetAsync()
    {
        if (!string.IsNullOrEmpty(selectedSetName))
        {
            selectedSet = await BingoService.GetByNameAsync(selectedSetName);
            if (selectedSet != null)
            {
                ResetGame();
            }
        }
        else
        {
            selectedSet = null;
        }
    }
    
    // Keep the synchronous version for backward compatibility
    private void LoadSelectedSet()
    {
        if (!string.IsNullOrEmpty(selectedSetName))
        {
            selectedSet = BingoService.GetByName(selectedSetName);
            if (selectedSet != null)
            {
                ResetGame();
            }
        }
        else
        {
            selectedSet = null;
        }
    }

    private void ResetGame()
    {
        // Cancel any ongoing animations first
        animationCts?.Cancel();
        if (animationCts != null)
        {
            animationCts.Dispose();
            animationCts = null;
        }

        if (selectedSet?.Items?.Length > 0)
        {
            availableItems = new List<string>(selectedSet.Items);
            calledItems.Clear();
            currentItem = null;
            displayItem = null;
            isSelecting = false;
            isSelected = false;
            isAnimating = false;
            // Assign a new random color theme
            string previousColor = currentThemeColor;
            string newColor;
            do
            {
                newColor = darkColors[random.Next(darkColors.Length)];
            } while (darkColors.Length > 1 && newColor == previousColor);
            currentThemeColor = newColor;
            wheelRotation = 0;
            StateHasChanged();
        }
    }

    private void ConfirmNewGame()
    {
        if (calledItems.Count > 0)
        {
            confirmTitle = "Confirm New Game";
            confirmMessage = "Are you sure you want to start a new game? This will reset the current game.";
            showConfirmDialog = true;
            confirmAction = () =>
            {
                NewGame();
                return Task.CompletedTask;
            };
        }
        else
        {
            // No game in progress, just reset
            NewGame();
        }
    }

    private void NewGame()
    {
        ResetGame();
    }

    private void CancelConfirmation()
    {
        showConfirmDialog = false;
        pendingSetName = selectedSetName; // Reset pending selection if canceled
        StateHasChanged();
    }

    private async Task ConfirmAction()
    {
        showConfirmDialog = false;
        if (confirmAction != null)
        {
            await confirmAction.Invoke();
            confirmAction = null;
        }
    }

    private async Task SelectNext()
    {
        if (availableItems.Count == 0 || isSelecting)
        {
            return;
        }

        try
        {
            isSelecting = true;
            isSelected = false;
            
            if (useWheel)
            {
                // Select the final item first
                int randomIndex = random.Next(0, availableItems.Count);
                currentItem = availableItems[randomIndex];
                
                // Calculate the final rotation to make the selected item land at the pointer
                double segmentAngle = 360.0 / availableItems.Count;
                double itemAngle = segmentAngle * randomIndex;
                
                // Since the coordinate system in the wheel rendering has 0 degrees at the right side
                // (notice the -90 in the clipPath calculation) and the pointer is also at the right,
                // we need to align the center of the item's segment with the 0-degree mark
                
                // Center of the item's segment
                double itemCenterAngle = itemAngle + (segmentAngle / 2);
                // Fixed number of rotations (5-8) for visual effect plus the alignment angle
                double targetRotation = (random.Next(5, 8) * 360) + (360 - itemCenterAngle);
                
                // Fix the rotation to ensure it's within proper range
                targetRotation = targetRotation % 360 == 0 ? targetRotation + 1 : targetRotation;
                
                // Start the wheel spinning animation
                wheelRotation = 0;
                isWheelSlowingDown = false;
                isWheelDramatic = false;
                showWheelSparkles = false;
                StateHasChanged();
                
                // Trigger the animation by setting the final rotation
                await Task.Delay(50); // Small delay to ensure the initial state is rendered
                wheelRotation = targetRotation;
                StateHasChanged();
                
                // Main spin (3.0 seconds)
                await Task.Delay(3000);
                
                // Subtle slowing down phase (0.3 seconds)
                isWheelSlowingDown = true;
                StateHasChanged();
                await Task.Delay(300);
                
                // Elegant finale with sparkles (0.4 seconds)
                isWheelDramatic = true;
                showWheelSparkles = true;
                StateHasChanged();
                await Task.Delay(400);
                
                // Update game state
                availableItems.RemoveAt(randomIndex);
                calledItems.Add(currentItem);
                displayItem = currentItem;
                
                // Keep the final state visible (3 seconds)
                await Task.Delay(3000);
                
                // Reset effects
                isWheelDramatic = false;
                showWheelSparkles = false;
                isWheelSlowingDown = false;
                StateHasChanged();
                
                // Reset wheel position
                wheelRotation = 0;
                StateHasChanged();
            }
            else
            {
                // Original card-based selection animation
                displayItem = availableItems[random.Next(availableItems.Count)];
                currentItem = null;
                isAnimating = true;
                StateHasChanged();

                // Cancel any existing animation
                animationCts?.Cancel();
                animationCts = new CancellationTokenSource();
                var token = animationCts.Token;

                // Fast cycling at the beginning
                var fastRotations = 15;
                for (int i = 0; i < fastRotations && !token.IsCancellationRequested; i++)
                {
                    displayItem = availableItems[random.Next(availableItems.Count)];
                    StateHasChanged();
                    await Task.Delay(50, token);
                }
                
                // Medium speed cycling
                var mediumRotations = 10;
                for (int i = 0; i < mediumRotations && !token.IsCancellationRequested; i++)
                {
                    displayItem = availableItems[random.Next(availableItems.Count)];
                    StateHasChanged();
                    await Task.Delay(100, token);
                }
                
                // Slow down dramatically for final selections
                var slowRotations = 7;
                for (int i = 0; i < slowRotations && !token.IsCancellationRequested; i++)
                {
                    displayItem = availableItems[random.Next(availableItems.Count)];
                    StateHasChanged();
                    await Task.Delay(200, token);
                }

                if (!token.IsCancellationRequested)
                {
                    // Select the final item
                    int randomIndex = random.Next(0, availableItems.Count);
                    currentItem = availableItems[randomIndex];
                    displayItem = currentItem;
                    availableItems.RemoveAt(randomIndex);
                    calledItems.Add(currentItem);
                }
            }

            // Show final selection
            isSelecting = false;
            isSelected = true;
            isAnimating = false;
            StateHasChanged();
        }
        catch (OperationCanceledException)
        {
            // Animation was cancelled
        }
        finally
        {
            isSelecting = false;
            if (animationCts != null)
            {
                animationCts.Dispose();
                animationCts = null;
            }
        }
    }

    private void ToggleItem(string item)
    {
        if (calledItems.Contains(item))
        {
            calledItems.Remove(item);
            availableItems.Add(item);
        }
        else
        {
            calledItems.Add(item);
            availableItems.Remove(item);
        }
        StateHasChanged();
    }

    private async Task SetMode(bool useWheelMode)
    {
        if (useWheel != useWheelMode)
        {
            useWheel = useWheelMode;
            await OnWheelPreferenceChanged();
        }
    }

    public void Dispose()
    {
        // Clean up any resources when the component is disposed
        BingoService.OnSetsChanged -= OnBingoSetsChanged;
        animationCts?.Cancel();
        animationCts?.Dispose();
        animationCts = null;
    }
}
